/*
 * Copyright 2025 ObjectBox Ltd. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// automatically generated by the FlatBuffers compiler, do not modify

package io.objectbox.config;

import io.objectbox.flatbuffers.BaseVector;
import io.objectbox.flatbuffers.BooleanVector;
import io.objectbox.flatbuffers.ByteVector;
import io.objectbox.flatbuffers.Constants;
import io.objectbox.flatbuffers.DoubleVector;
import io.objectbox.flatbuffers.FlatBufferBuilder;
import io.objectbox.flatbuffers.FloatVector;
import io.objectbox.flatbuffers.IntVector;
import io.objectbox.flatbuffers.LongVector;
import io.objectbox.flatbuffers.ShortVector;
import io.objectbox.flatbuffers.StringVector;
import io.objectbox.flatbuffers.Struct;
import io.objectbox.flatbuffers.Table;
import io.objectbox.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * Options to open a store with. Set only the values you want; defaults are used otherwise.
 * Reminder: enable "force defaults" in the FlatBuffers builder, e.g. to pass in booleans with value "false".
 * NOTE: some setting are for "advanced" purposes that you can typically ignore for regular usage.
 *       When using advanced setting, you should know exactly what you are doing.
 */
@SuppressWarnings("unused")
public final class FlatStoreOptions extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_23_5_26(); }
  public static FlatStoreOptions getRootAsFlatStoreOptions(ByteBuffer _bb) { return getRootAsFlatStoreOptions(_bb, new FlatStoreOptions()); }
  public static FlatStoreOptions getRootAsFlatStoreOptions(ByteBuffer _bb, FlatStoreOptions obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public FlatStoreOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Location of the database on disk; this will be a directory containing files.
   */
  public String directoryPath() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer directoryPathAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer directoryPathInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Provide a data model, e.g. to initialize or update the schema.
   */
  public int modelBytes(int j) { int o = __offset(6); return o != 0 ? bb.get(__vector(o) + j * 1) & 0xFF : 0; }
  public int modelBytesLength() { int o = __offset(6); return o != 0 ? __vector_len(o) : 0; }
  public ByteVector modelBytesVector() { return modelBytesVector(new ByteVector()); }
  public ByteVector modelBytesVector(ByteVector obj) { int o = __offset(6); return o != 0 ? obj.__assign(__vector(o), bb) : null; }
  public ByteBuffer modelBytesAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer modelBytesInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * This maximum size setting is meant to prevent your database from growing to unexpected sizes,
   * e.g. caused by programming error.
   * If your app runs into errors like "db full", you may consider to raise the limit.
   */
  public long maxDbSizeInKbyte() { int o = __offset(8); return o != 0 ? bb.getLong(o + bb_pos) : 0L; }
  /**
   * File permissions given in Unix style octal bit flags (e.g. 0644). Ignored on Windows.
   * Note: directories become searchable if the "read" or "write" permission is set (e.g. 0640 becomes 0750).
   */
  public long fileMode() { int o = __offset(10); return o != 0 ? (long)bb.getInt(o + bb_pos) & 0xFFFFFFFFL : 0L; }
  /**
   * The maximum number of readers (related to read transactions).
   * "Readers" are an finite resource for which we need to define a maximum number upfront.
   * The default value is enough for most apps and usually you can ignore it completely.
   * However, if you get the OBX_ERROR_MAX_READERS_EXCEEDED error, you should verify your
   * threading. For each thread, ObjectBox uses multiple readers. Their number (per thread) depends
   * on number of types, relations, and usage patterns. Thus, if you are working with many threads
   * (e.g. in a server-like scenario), it can make sense to increase the maximum number of readers.
   *
   * Note: The internal default is currently 126. So when hitting this limit, try value s around 200-500.
   *
   * Note: Each thread that performed a read transaction and is still alive holds on to a reader slot.
   *       These slots only get vacated when the thread ends. Thus be mindful with the number of active threads.
   *       Alternatively, you can opt to try the experimental noReaderThreadLocals option flag.
   */
  public long maxReaders() { int o = __offset(12); return o != 0 ? (long)bb.getInt(o + bb_pos) & 0xFFFFFFFFL : 0L; }
  /**
   * When a database is opened, ObjectBox can perform additional consistency checks on its database structure.
   * Reliable file systems already guarantee consistency, so this is primarily meant to deal with unreliable
   * OSes, file systems, or hardware.
   * Note: ObjectBox builds upon ACID storage, which already has strong consistency mechanisms in place.
   */
  public int validateOnOpenPages() { int o = __offset(14); return o != 0 ? bb.getShort(o + bb_pos) & 0xFFFF : 0; }
  /**
   * To fine-tune database validation, you can specify a limit on how much data is looked at.
   * This is measured in "pages" with a page typically holding 4K.
   * Usually a low number (e.g. 1-20) is sufficient and does not impact startup performance significantly.
   * This is only to be used with ValidateOnOpenMode "Regular" and "WithLeaves".
   */
  public long validateOnOpenPageLimit() { int o = __offset(16); return o != 0 ? bb.getLong(o + bb_pos) : 0L; }
  /**
   * Don't touch unless you know exactly what you are doing:
   * Advanced setting typically meant for language bindings (not end users). See PutPaddingMode description.
   */
  public int putPaddingMode() { int o = __offset(18); return o != 0 ? bb.getShort(o + bb_pos) & 0xFFFF : 0; }
  /**
   * Advanced setting meant only for special scenarios: opens the database in a limited, schema-less mode.
   * If you don't know what this means exactly: ignore this flag.
   */
  public boolean skipReadSchema() { int o = __offset(20); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Advanced setting recommended to be used together with read-only mode to ensure no data is lost.
   * Ignores the latest data snapshot (committed transaction state) and uses the previous snapshot instead.
   * When used with care (e.g. backup the DB files first), this option may also recover data removed by the latest
   * transaction.
   */
  public boolean usePreviousCommit() { int o = __offset(22); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * NOT IMPLEMENTED YET. Placeholder for a future version only.
   * If consistency checks fail during opening the DB (see also the pagesToValidateOnOpen setting), ObjectBox
   * automatically switches to the previous commit (see also usePreviousCommit). This way, this constitutes
   * an auto-recover mode from severe failures. HOWEVER, keep in mind that any consistency failure
   * is an indication that something is very wrong with OS/hardware and thus you should also check
   * openedWithPreviousCommit(), e.g. to alert your users.
   */
  public boolean usePreviousCommitOnValidationFailure() { int o = __offset(24); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Open store in read-only mode: no schema update, no write transactions.
   */
  public boolean readOnly() { int o = __offset(26); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * For debugging purposes you may want enable specific logging.
   */
  public long debugFlags() { int o = __offset(28); return o != 0 ? (long)bb.getInt(o + bb_pos) & 0xFFFFFFFFL : 0L; }
  /**
   * Disables the usage of thread locals for "readers" related to read transactions.
   * This can make sense if you are using a lot of threads that are kept alive.
   *
   * Note: This is still experimental, as it comes with subtle behavior changes at a low level and may affect
   *       corner cases with e.g. transactions, which may not be fully tested at the moment.
   */
  public boolean noReaderThreadLocals() { int o = __offset(30); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Data size tracking is more involved than DB size tracking, e.g. it stores an internal counter.
   * Thus only use it if a stricter, more accurate limit is required.
   * It tracks the size of actual data bytes of objects (system and metadata is not considered).
   * On the upside, reaching the data limit still allows data to be removed (assuming DB limit is not reached).
   * Max data and DB sizes can be combined; data size must be below the DB size.
   */
  public long maxDataSizeInKbyte() { int o = __offset(32); return o != 0 ? bb.getLong(o + bb_pos) : 0L; }
  /**
   * When a database is opened, ObjectBox can perform additional consistency checks on its database structure.
   * This enum is used to enable validation checks on a key/value level.
   */
  public int validateOnOpenKv() { int o = __offset(34); return o != 0 ? bb.getShort(o + bb_pos) & 0xFFFF : 0; }
  /**
   * Restores the database content from the given backup file (note: backup is a server-only feature).
   * By default, actually restoring the backup is only performed if no database already exists
   * (database does not contain data).
   * This behavior can be adjusted with backupRestoreFlags, e.g., to overwrite all existing data in the database.
   *
   * \note Backup files are created from an existing database using ObjectBox API.
   *
   * \note The following error types can occur for different error scenarios:
   *       * IO error: the backup file doesn't exist, couldn't be read or has an unexpected size,
   *       * format error: the backup-file is malformed
   *       * integrity error: the backup file failed integrity checks
   */
  public String backupFile() { int o = __offset(36); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer backupFileAsByteBuffer() { return __vector_as_bytebuffer(36, 1); }
  public ByteBuffer backupFileInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 36, 1); }
  /**
   * Flags to change the default behavior for restoring backups, e.g. what should happen to existing data.
   */
  public long backupRestoreFlags() { int o = __offset(38); return o != 0 ? (long)bb.getInt(o + bb_pos) & 0xFFFFFFFFL : 0L; }

  public static int createFlatStoreOptions(FlatBufferBuilder builder,
      int directoryPathOffset,
      int modelBytesOffset,
      long maxDbSizeInKbyte,
      long fileMode,
      long maxReaders,
      int validateOnOpenPages,
      long validateOnOpenPageLimit,
      int putPaddingMode,
      boolean skipReadSchema,
      boolean usePreviousCommit,
      boolean usePreviousCommitOnValidationFailure,
      boolean readOnly,
      long debugFlags,
      boolean noReaderThreadLocals,
      long maxDataSizeInKbyte,
      int validateOnOpenKv,
      int backupFileOffset,
      long backupRestoreFlags) {
    builder.startTable(18);
    FlatStoreOptions.addMaxDataSizeInKbyte(builder, maxDataSizeInKbyte);
    FlatStoreOptions.addValidateOnOpenPageLimit(builder, validateOnOpenPageLimit);
    FlatStoreOptions.addMaxDbSizeInKbyte(builder, maxDbSizeInKbyte);
    FlatStoreOptions.addBackupRestoreFlags(builder, backupRestoreFlags);
    FlatStoreOptions.addBackupFile(builder, backupFileOffset);
    FlatStoreOptions.addDebugFlags(builder, debugFlags);
    FlatStoreOptions.addMaxReaders(builder, maxReaders);
    FlatStoreOptions.addFileMode(builder, fileMode);
    FlatStoreOptions.addModelBytes(builder, modelBytesOffset);
    FlatStoreOptions.addDirectoryPath(builder, directoryPathOffset);
    FlatStoreOptions.addValidateOnOpenKv(builder, validateOnOpenKv);
    FlatStoreOptions.addPutPaddingMode(builder, putPaddingMode);
    FlatStoreOptions.addValidateOnOpenPages(builder, validateOnOpenPages);
    FlatStoreOptions.addNoReaderThreadLocals(builder, noReaderThreadLocals);
    FlatStoreOptions.addReadOnly(builder, readOnly);
    FlatStoreOptions.addUsePreviousCommitOnValidationFailure(builder, usePreviousCommitOnValidationFailure);
    FlatStoreOptions.addUsePreviousCommit(builder, usePreviousCommit);
    FlatStoreOptions.addSkipReadSchema(builder, skipReadSchema);
    return FlatStoreOptions.endFlatStoreOptions(builder);
  }

  public static void startFlatStoreOptions(FlatBufferBuilder builder) { builder.startTable(18); }
  public static void addDirectoryPath(FlatBufferBuilder builder, int directoryPathOffset) { builder.addOffset(0, directoryPathOffset, 0); }
  public static void addModelBytes(FlatBufferBuilder builder, int modelBytesOffset) { builder.addOffset(1, modelBytesOffset, 0); }
  public static int createModelBytesVector(FlatBufferBuilder builder, byte[] data) { return builder.createByteVector(data); }
  public static int createModelBytesVector(FlatBufferBuilder builder, ByteBuffer data) { return builder.createByteVector(data); }
  public static void startModelBytesVector(FlatBufferBuilder builder, int numElems) { builder.startVector(1, numElems, 1); }
  public static void addMaxDbSizeInKbyte(FlatBufferBuilder builder, long maxDbSizeInKbyte) { builder.addLong(2, maxDbSizeInKbyte, 0L); }
  public static void addFileMode(FlatBufferBuilder builder, long fileMode) { builder.addInt(3, (int) fileMode, (int) 0L); }
  public static void addMaxReaders(FlatBufferBuilder builder, long maxReaders) { builder.addInt(4, (int) maxReaders, (int) 0L); }
  public static void addValidateOnOpenPages(FlatBufferBuilder builder, int validateOnOpenPages) { builder.addShort(5, (short) validateOnOpenPages, (short) 0); }
  public static void addValidateOnOpenPageLimit(FlatBufferBuilder builder, long validateOnOpenPageLimit) { builder.addLong(6, validateOnOpenPageLimit, 0L); }
  public static void addPutPaddingMode(FlatBufferBuilder builder, int putPaddingMode) { builder.addShort(7, (short) putPaddingMode, (short) 0); }
  public static void addSkipReadSchema(FlatBufferBuilder builder, boolean skipReadSchema) { builder.addBoolean(8, skipReadSchema, false); }
  public static void addUsePreviousCommit(FlatBufferBuilder builder, boolean usePreviousCommit) { builder.addBoolean(9, usePreviousCommit, false); }
  public static void addUsePreviousCommitOnValidationFailure(FlatBufferBuilder builder, boolean usePreviousCommitOnValidationFailure) { builder.addBoolean(10, usePreviousCommitOnValidationFailure, false); }
  public static void addReadOnly(FlatBufferBuilder builder, boolean readOnly) { builder.addBoolean(11, readOnly, false); }
  public static void addDebugFlags(FlatBufferBuilder builder, long debugFlags) { builder.addInt(12, (int) debugFlags, (int) 0L); }
  public static void addNoReaderThreadLocals(FlatBufferBuilder builder, boolean noReaderThreadLocals) { builder.addBoolean(13, noReaderThreadLocals, false); }
  public static void addMaxDataSizeInKbyte(FlatBufferBuilder builder, long maxDataSizeInKbyte) { builder.addLong(14, maxDataSizeInKbyte, 0L); }
  public static void addValidateOnOpenKv(FlatBufferBuilder builder, int validateOnOpenKv) { builder.addShort(15, (short) validateOnOpenKv, (short) 0); }
  public static void addBackupFile(FlatBufferBuilder builder, int backupFileOffset) { builder.addOffset(16, backupFileOffset, 0); }
  public static void addBackupRestoreFlags(FlatBufferBuilder builder, long backupRestoreFlags) { builder.addInt(17, (int) backupRestoreFlags, (int) 0L); }
  public static int endFlatStoreOptions(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishFlatStoreOptionsBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset); }
  public static void finishSizePrefixedFlatStoreOptionsBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public FlatStoreOptions get(int j) { return get(new FlatStoreOptions(), j); }
    public FlatStoreOptions get(FlatStoreOptions obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

